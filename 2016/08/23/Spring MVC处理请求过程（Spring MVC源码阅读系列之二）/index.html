
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>Spring MVC处理请求过程(Spring MVC源码阅读系列之二) | WoodyOilove&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文是Spring MVC源码阅读系列的第二篇，在上一篇Spring MVC的创建过程中我们介绍了SpringMVC的创建过程，本文讲给主要介绍当一个请求到达时，SpringMVC都做了些什么，即Spring MVC是如何处理请求的。
前言从上一篇Spring MVC的创建过程 我们知道Spring的HttpServletBean继承于HttpServlet，熟悉Servlet编程的同学都知道我们">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring MVC处理请求过程(Spring MVC源码阅读系列之二)">
<meta property="og:url" content="localhost:4000/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/index.html">
<meta property="og:site_name" content="WoodyOilove's Blog">
<meta property="og:description" content="本文是Spring MVC源码阅读系列的第二篇，在上一篇Spring MVC的创建过程中我们介绍了SpringMVC的创建过程，本文讲给主要介绍当一个请求到达时，SpringMVC都做了些什么，即Spring MVC是如何处理请求的。
前言从上一篇Spring MVC的创建过程 我们知道Spring的HttpServletBean继承于HttpServlet，熟悉Servlet编程的同学都知道我们">
<meta property="og:image" content="localhost:4000/img/SpringMVCRequest.png">
<meta property="og:image" content="localhost:4000/img/doDispatcherProcess.png">
<meta property="og:updated_time" content="2016-08-31T08:13:08.680Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring MVC处理请求过程(Spring MVC源码阅读系列之二)">
<meta name="twitter:description" content="本文是Spring MVC源码阅读系列的第二篇，在上一篇Spring MVC的创建过程中我们介绍了SpringMVC的创建过程，本文讲给主要介绍当一个请求到达时，SpringMVC都做了些什么，即Spring MVC是如何处理请求的。
前言从上一篇Spring MVC的创建过程 我们知道Spring的HttpServletBean继承于HttpServlet，熟悉Servlet编程的同学都知道我们">
<meta name="twitter:image" content="localhost:4000/img/SpringMVCRequest.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/oilove"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">WoodyOilove&#39;s Blog</a>
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">H</li>
        <li class="cara"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"></circle>
          <rect x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"></rect>
          <rect x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"></rect>
        </svg></li>
        <li class="cara">F</li>
        <li class="cara">O</li>
        <li class="cara">E</li>
        <li class="cara">N</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
      <!--<a class="main-nav-link st-search-show-outputs">Search</a>-->
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main"><article id="post-Spring MVC处理请求过程（Spring MVC源码阅读系列之二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/" class="article-date">
  <time datetime="2016-08-22T16:00:00.000Z" itemprop="datePublished">2016-08-23</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java框架/">Java框架</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring MVC处理请求过程(Spring MVC源码阅读系列之二)
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
          <div id="toc" class="toc-article">
            <strong class="toc-title">文章目錄</strong>
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC请求处理整体过程"><span class="toc-text">Spring MVC请求处理整体过程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-MVC的请求处理概述"><span class="toc-text">Spring MVC的请求处理概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#FrameworkServlet"><span class="toc-text">FrameworkServlet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#DispatcherServlet"><span class="toc-text">DispatcherServlet</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#doDispatcher流程"><span class="toc-text">doDispatcher流程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-text">参考资料</span></a></li></ol>
          </div>
        
        <p>本文是Spring MVC源码阅读系列的第二篇，在上一篇<a href="/2016/08/18/Spring%20MVC的创建过程（SpringMVC源码阅读系列之一）%2F">Spring MVC的创建过程</a>中我们介绍了SpringMVC的创建过程，本文讲给主要介绍当一个请求到达时，SpringMVC都做了些什么，即Spring MVC是如何处理请求的。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从上一篇<a href="/2016/08/18/Spring%20MVC的创建过程（SpringMVC源码阅读系列之一）%2F">Spring MVC的创建过程</a> 我们知道Spring的HttpServletBean继承于HttpServlet，熟悉Servlet编程的同学都知道我们要编写一个新的Servlet只需继承HttpServlet，并重写相应的方法即可，当一个新的请求到来时，首先从Servlet接口的service方法开始，在HttpServlet的service方法中根据请求的类型不同将请求路由到对应的方法，Spring MVC的HttpServlet继承于Httpservlet类，换句话说Spring MVC也是重写了HttpServlet相应的方法来处理请求，还是内有乾坤，下面我们将遵循由整体到局部的学习方式，先了解Spring MVC处理请求的整体过程。</p>
<a id="more"></a>
<h1 id="Spring-MVC请求处理整体过程"><a href="#Spring-MVC请求处理整体过程" class="headerlink" title="Spring MVC请求处理整体过程"></a>Spring MVC请求处理整体过程</h1><p>Spring MVC请求处理的大体过程时请求由DispatcherServlet根据处理器映射确定控制器并分配给它，在控制器完成处理后，请求会被发送给一个根据视图解析器确定的视图来呈现输出结果。如下图：<br><img src="/img/SpringMVCRequest.png" alt="SpringMVC请求处理整体过程"></p>
<ol>
<li>web应用服务器接收到一个新请求是，如果匹配DispatcherServlet的请求映射路径，web容器将该请求转发给DispatcherServlet进行处理</li>
<li>DispatcherServlet接收到请求后，将根据请求的信息及HandlerMapping的配置找到处理请求的处理器（Handler）</li>
<li>当DispatcherServlet根据HandlerMapping得到对应当前请求的Handler后，通过HandlerAdapter对Handler进行封装，以统一的适配器接口调用Handler</li>
<li>处理器完成业务逻辑的处理后将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息</li>
<li>ModelAndView中包含的是“逻辑视图名”，而非真正的视图对象，DispatcherServlet借助ViewResolver完成逻辑视图名到真实视图名对象的解析工作</li>
<li>当得到真实的视图对象View后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染</li>
<li>最终客户端得到的可能是HTML页面或者其他对象</li>
</ol>
<h1 id="Spring-MVC的请求处理概述"><a href="#Spring-MVC的请求处理概述" class="headerlink" title="Spring MVC的请求处理概述"></a>Spring MVC的请求处理概述</h1><p>Spring MVC的三个Servlet中的HttpservletBean主要参与了创建工作，没有涉及请求的处理；FrameworkServlet重写了除了doHead的所有处理请求的方法；DispatcherServlet描述了具体处理请求顶层设计结构。<br>接下来我们先看看FrameworkServlet是如何重写处理请求的方法，又是如何将请求交给DispatcherServlet进行具体的请求处理的。</p>
<h1 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h1><p>首先我们先来看看FrameworkServlet的service方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">		<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">	String method = request.getMethod();</div><div class="line">	<span class="comment">//对PATCH类型请求的处理</span></div><div class="line">	<span class="keyword">if</span> (method.equalsIgnoreCase(RequestMethod.PATCH.name())) &#123;</div><div class="line">		processRequest(request, response);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">super</span>.service(request, response);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面的代码我们可以看出，FrameworkServlet在service方法中增加了对PATCH类型请求的处理，其他类型的请求直接交给了父类进行处理，即调用HttpServlet的service方法进行处理。为什么要这样做呢，不再调用super.service(),而是直接将请求交给processRequest处理不是更简单吗？从结构上来看确实如此，但是如果这样做的话会存在一些问题。例如：我们为了某种特殊需求需要在Post请求处理前对request进行一些处理，这时可能会新建一个继承自DispatcherServlet的类，然后覆盖doPost方法，在里面对request进行处理，然后再调用super.doPost方法，但是父类根本没有调用doPost，这时就会出现问题，虽然有其他方法来解决这个问题，但按正常的逻辑，调用doPost应该可以完成才合理，而且一般情况下开发者并不需要对Spring MVC 的内部结构非常了解。所以Spring MVC的这种做法是有必要的。从前言我们已经知道HttpServlet的service方法是根据请求类型的不同将请求路由到不同的处理方法的，那么接下来我们来看看doGet方法（其余方法需要自己处理的方法与doGet类似）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">	<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	processRequest(request, response);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们从上面的代码以及其余的doXXX类型方法中可以发现，这里所做的事情与Httpservle里将不同类型的请求路由到不同方法进行处理的思路正好相反，这里又将所有的请求合并到了processRequest方法中。下面我们将一步步解开这神秘的面纱。首先我们先来看看processRequest方法，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></div><div class="line">	<span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">	<span class="keyword">long</span> startTime = System.currentTimeMillis();</div><div class="line">	Throwable failureCause = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//获取LocaleContextHolder中原来保存的LocaleContext</span></div><div class="line">	LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</div><div class="line">	<span class="comment">//获取当前请求的LocaleContext</span></div><div class="line">	LocaleContext localeContext = buildLocaleContext(request);</div><div class="line">	<span class="comment">//获取RequestContextHolder中原来保存的RequestAttributes</span></div><div class="line">	RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</div><div class="line">	<span class="comment">//获取当前请求的ServletRequestAttributes</span></div><div class="line">	ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</div><div class="line"></div><div class="line">	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line">	asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</div><div class="line">	<span class="comment">//将当前请求的LocaleContext和ServletRequestAttributes设置到LocaleContextHolder和RequestContextHolder中</span></div><div class="line">	initContextHolders(request, localeContext, requestAttributes);</div><div class="line"></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	    <span class="comment">//具体处理方法入口</span></div><div class="line">		doService(request, response);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (ServletException ex) &#123;</div><div class="line">		failureCause = ex;</div><div class="line">		<span class="keyword">throw</span> ex;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">		failureCause = ex;</div><div class="line">		<span class="keyword">throw</span> ex;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">		failureCause = ex;</div><div class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Request processing failed"</span>, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		<span class="comment">//恢复原来的LocaleContext和ServiceRequestAttributes到LocaleContextHolder和RequestContextHolder，避免影响Servlet以外的处理，如Filter</span></div><div class="line">		resetContextHolders(request, previousLocaleContext, previousAttributes);</div><div class="line">		<span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</div><div class="line">			requestAttributes.requestCompleted();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">			<span class="keyword">if</span> (failureCause != <span class="keyword">null</span>) &#123;</div><div class="line">				<span class="keyword">this</span>.logger.debug(<span class="string">"Could not complete request"</span>, failureCause);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">					logger.debug(<span class="string">"Leaving response open for concurrent processing"</span>);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">this</span>.logger.debug(<span class="string">"Successfully completed request"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//发布ServletRequestHandlerEvent消息</span></div><div class="line">		publishRequestHandledEvent(request, response, startTime, failureCause);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上面的代码中核心语句时doService(request,response)，这是一个模板方法，在DispatcherServlet中具体实现。在doService前后还做了一些事情，也就是大家熟悉的装饰模式：首先获取了LocalContextHolder和RequestContextHolder中原来保存的LocaleContext和RequestAttributes并设置到previousLocaleContext和previousAttributes临时属性，用于最后将原来的LocaleContext和RequestAttributes恢复；然后调用buildLocalContext和buildRequestAttributes方法获取到当前请求的LocaleContext和RequestAttributes，并通过initContextHolders方法将它们设置到LocaleContextHolder和RequestContextHolder中，最后在finally中将原来的LocaleContext和RequestAttributes恢复到LocaleContextHolder和RequestAttributesHolder中，并调用publishRequestHandleEvent方法发布一个ServletRequestHandledEvent类型的消息。</p>
<p>或许大家对于设置LocaleContext和RequestAttributes不是很理解，在这我们再深入探索一番，帮助大家更好地理解其目的。首先我们要知道LocaleContext里存放的是Locale(本地化信息),因而是用于获取Locale，而RequestAttributes是spring的一个接口，用于管理request和session的属性，通过它可以get/set/removeAttribute，根据scope参数判断是操作request还是session，使用的具体实现类是ServletRequestAttributes类，它还封装了request、response和session，而且提供了get方法，可以直接获取。到这里或许大家对于LocaleContext和RequestAttributes的作用有了大概的了解，可是它们又是如何使用的呢。通过debug进initContextHolders方法，我们可以发现LocalContext和RequestAttributes是保存在LocalContextHolders和RequestAttributesHolders中的。接下来我们来看看LocalContextHolders和RequestAttributesHolders。</p>
<p>首先我们先来看看LocalContextHolders，这是一个abstract类，但里面的方法都是static的，可以直接调用，而且没有父类也没子类，因而我们不能对其进行实例化，只能调用其static方法。这种abstract的使用方式值得我们学习。在LocaleContextHolder中定义了两个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LocaleContext&gt; localeContextHolder =</div><div class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;LocaleContext&gt;(<span class="string">"Locale context"</span>);</div><div class="line"></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;LocaleContext&gt; inheritableLocaleContextHolder =</div><div class="line">			<span class="keyword">new</span> NamedInheritableThreadLocal&lt;LocaleContext&gt;(<span class="string">"Locale context"</span>);</div></pre></td></tr></table></figure></p>
<p>LocaleContextHolder还提供了get/set方法，可以获取和设置LocaleContext，另外还提供了get/setLocale方法，可以直接操作Locale，保存在ThreadLocal中能够保证多个请求之间相互独立，互不影响，对于ThreadLocal的作用及其实现原理，我们将在后面的文章中进行说明。相信到此，大家已经初步理解这样做的目的：为了方便在项目的任何地方使用Locale，而不需要将其作为参数进行传递到对应的地方，只需要调用一下LocaleContextHolder的getLocale()方法即可。</p>
<p>RequestAttributesHolder也是一样的道理，里面封装了RequestAttributes，可以get/set/removeAttribute，而且因为实际封装的是ServletRequestAttributes，因此还可以通过get/set方法获取或修改request、response、session对象。</p>
<p><strong>概括总结一下FrameworkServlet处理请求的过程：</strong><br>FrameworkServlet重写除doHead的所有处理请求的方法，并在service方法中增加了对PATCH类型请求的处理，其他类型的请求直接交给了父类进行处理；与HttpServlet里将不同类型的请求路径路由到不同方法进行处理的思路相反，doXXX类型方法又将所有请求合并到了processRequest方法中；在processRequet方法中，除了异步请求和调用doService方法具体处理请求，主要做了两件事：</p>
<ol>
<li>对LocaleContext和RequestAttributes的设置，为了便于在其他层次调用locale信息和request信息；而对它们的恢复是为了不影响Servlet以外的处理，如Filter</li>
<li>处理完成后发布了ServletRequestHandledEvent消息</li>
</ol>
<h1 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h1><p>接下来我们将来弄明白Spring MVC最核心的类——DispatcherServlet，整个处理过程的顶层设计都在这里。从上面FrameworkServlet的分析中，我们知道DispatcherServlet里面执行处理的入口方法是doService，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		String resumed = WebAsyncUtils.getAsyncManager(request).hasConcurrentResult() ? <span class="string">" resumed"</span> : <span class="string">""</span>;</div><div class="line">		logger.debug(<span class="string">"DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span> + resumed +</div><div class="line">			<span class="string">" processing "</span> + request.getMethod() + <span class="string">" request for ["</span> + getRequestUri(request) + <span class="string">"]"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//当include请求时对request的Attribute做快照备份</span></div><div class="line">	Map&lt;String, Object&gt; attributesSnapshot = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">if</span> (WebUtils.isIncludeRequest(request)) &#123;</div><div class="line">		attributesSnapshot = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</div><div class="line">		Enumeration&lt;?&gt; attrNames = request.getAttributeNames();</div><div class="line">		<span class="keyword">while</span> (attrNames.hasMoreElements()) &#123;</div><div class="line">			String attrName = (String) attrNames.nextElement();</div><div class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.cleanupAfterInclude || attrName.startsWith(<span class="string">"org.springframework.web.servlet"</span>)) &#123;</div><div class="line">				attributesSnapshot.put(attrName, request.getAttribute(attrName));</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//对request设置一些属性，便于具体处理时调用</span></div><div class="line">	request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext());</div><div class="line">	request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.localeResolver);</div><div class="line">	request.setAttribute(THEME_RESOLVER_ATTRIBUTE, <span class="keyword">this</span>.themeResolver);</div><div class="line">	request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource());</div><div class="line">	<span class="comment">//flashMap主要用于Redirect转发时参数的传递</span></div><div class="line">	FlashMap inputFlashMap = <span class="keyword">this</span>.flashMapManager.retrieveAndUpdate(request, response);</div><div class="line">	<span class="keyword">if</span> (inputFlashMap != <span class="keyword">null</span>) &#123;</div><div class="line">		request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap));</div><div class="line">	&#125;</div><div class="line">	request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, <span class="keyword">new</span> FlashMap());</div><div class="line">	request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, <span class="keyword">this</span>.flashMapManager);</div><div class="line"></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		doDispatch(request, response);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class="line">			<span class="comment">//还原request快照的备份</span></div><div class="line">			<span class="keyword">if</span> (attributesSnapshot != <span class="keyword">null</span>) &#123;</div><div class="line">				restoreAttributesAfterInclude(request, attributesSnapshot);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由上面的代码我们可以看出doService并没有直接进行处理，而是交给了doDispatcher进行具体的处理，在交给doDispatcher处理前，doService还做了以下的事：</p>
<ol>
<li>判断是不是include请求，如果是则对request的Attribute做个快照备份，等doDispatcher处理完成后进行还原。</li>
<li>对request设置了一些属性，至于FlashMap则是主要用于Redirect转发时参数的传递。</li>
</ol>
<p>分析完doService，接下来我们将对doDispatcher进行分析，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	HttpServletRequest processedRequest = request;</div><div class="line">	HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</div><div class="line"></div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">		ModelAndView mv = <span class="keyword">null</span>;</div><div class="line">		Exception dispatchException = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//检查是不是上传请求</span></div><div class="line">			processedRequest = checkMultipart(request);</div><div class="line">			multipartRequestParsed = (processedRequest != request);</div><div class="line"></div><div class="line">			<span class="comment">//根据request找到Handler</span></div><div class="line">			mappedHandler = getHandler(processedRequest);</div><div class="line">			<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</div><div class="line">				noHandlerFound(processedRequest, response);</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">//根据Handler找到HandlerAdapter</span></div><div class="line">			HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line"></div><div class="line">			<span class="comment">// 处理GET、HEAD请求的Last-Modified</span></div><div class="line">			String method = request.getMethod();</div><div class="line">			<span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</div><div class="line">			<span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</div><div class="line">				<span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</div><div class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">					logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</div><div class="line">					<span class="keyword">return</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//执行相应的Interceptor的preHandle</span></div><div class="line">			<span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// HandlerAdapter使用Handler处理请求</span></div><div class="line">			mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</div><div class="line">			<span class="comment">//如果需要异步处理，直接返回</span></div><div class="line">			<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">			<span class="comment">//当view为空时，根据request设置默认view，如Handler返回值为void</span></div><div class="line">			applyDefaultViewName(request, mv);</div><div class="line">			<span class="comment">//执行相应Interceptor的postHandle</span></div><div class="line">			mappedHandler.applyPostHandle(processedRequest, response, mv);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">			dispatchException = ex;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//处理返回结果，包括处理异常、渲染页面，发出完成通知触发Interceptor的afterCompletion</span></div><div class="line">		processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">		triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Error err) &#123;</div><div class="line">		triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">finally</span> &#123;</div><div class="line">		<span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</div><div class="line">			<span class="comment">// Instead of postHandle and afterCompletion</span></div><div class="line">			<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">				mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">// 删除上传资源</span></div><div class="line">			<span class="keyword">if</span> (multipartRequestParsed) &#123;</div><div class="line">				cleanupMultipart(processedRequest);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述的代码中最核心的代码只有4句，它们的任务分别是：</p>
<ol>
<li>根据request找到Handler</li>
<li>根据Handler找到对应的HandlerAdapter</li>
<li>用HandlerAdapter处理Handler</li>
<li>调用processRequest方法处理上面处理之后的结果（包含找到View并渲染输出给用户）<br>对应的代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mappedHandler = getHandler(processedRequset)</div><div class="line">HandlerAdaptor ha = getHandlerAdapter(mappedHandler.getHandler());</div><div class="line">mv = ha.handle(processedRequest,response,mappedHandler.getHandler());</div><div class="line">processDispatchResult(processRequest,response,mappedHandler,mv,dispatcherException);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>了解完doDispatcher的核心语句之后，我们再来详细分析其内部结构以及处理的流程。</p>
<p>doDispatcher首先检查是不是上传请求，如果是则将request转换为MultipartHttpServletRequest，并将multipartRequestParsed标志设置为true。</p>
<p>然后通过getHandler获取Handler处理器链，具体的获取过程，后面分析HandlerMapping时再进行详细分析。</p>
<p>接下来处理GET、HEAD请求的Last-Modified，当浏览器第一次跟服务器请求资源时，服务器在返回的请求头里会包含一个last-Modified的属性，代表本资源最后是什么时候修改的。在浏览器以后发送请求时会同时发送之前接收到的last-modified，服务器接收到带Last-modified的请求后会用其值和自己实际资源的最后修改时间作对比，如果资源过期了则返回新的资源（同时返回新的last-modified），否则直接返回304状态吗表示资源未过期，浏览器直接使用之前缓存的结果。</p>
<p>接下来依次调用相应的Interceptor的preHandle。处理完preHandle后就到了此方法最关键的地方——让HandlerAdapter使用Handler处理请求，Controller就是在这执行的，具体内容在分析HandlerAdapter时在详细解释。</p>
<p>Handler处理完请求后，如果需要异步处理则直接返回，如果不需要异步处理，当view为空时，设置默认view，然后执行相应的Interceptor的postHandle。</p>
<p>至此，请求处理的内容就完成了，接下来使用processDispatchResult方法处理前面返回的结果，其中包括处理异常、渲染页面、触发Interceptor的afterCompletion方法三部分内容。</p>
<p>最后是doDispatcher的异常处理，doDispatcher有两层异常处理，内层是捕获在对请求进行处理过程中抛出的异常，外层主要是在处理渲染页面时抛出的。<br>processDispatchResult代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDispatchResult</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></div><div class="line">			HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> errorView = <span class="keyword">false</span>;</div><div class="line">	<span class="comment">//如果请求处理的过程中有异常抛出则处理异常</span></div><div class="line">	<span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span> (exception <span class="keyword">instanceof</span> ModelAndViewDefiningException) &#123;</div><div class="line">			logger.debug(<span class="string">"ModelAndViewDefiningException encountered"</span>, exception);</div><div class="line">			mv = ((ModelAndViewDefiningException) exception).getModelAndView();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			Object handler = (mappedHandler != <span class="keyword">null</span> ? mappedHandler.getHandler() : <span class="keyword">null</span>);</div><div class="line">			mv = processHandlerException(request, response, handler, exception);</div><div class="line">			errorView = (mv != <span class="keyword">null</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">//渲染页面</span></div><div class="line">	<span class="keyword">if</span> (mv != <span class="keyword">null</span> &amp;&amp; !mv.wasCleared()) &#123;</div><div class="line">		render(mv, request, response);</div><div class="line">		<span class="keyword">if</span> (errorView) &#123;</div><div class="line">			WebUtils.clearErrorRequestAttributes(request);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(<span class="string">"Null ModelAndView returned to DispatcherServlet with name '"</span> + getServletName() + <span class="string">"': assuming HandlerAdapter completed request handling"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</div><div class="line">		<span class="comment">//如果启动了异步处理则返回</span></div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//发出请求处理完成的通知，触发Interceptor的afterCompletion</span></div><div class="line">	<span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</div><div class="line">		mappedHandler.triggerAfterCompletion(request, response, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">render</span><span class="params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">	<span class="comment">// Determine locale for request and apply it to the response.</span></div><div class="line">	Locale locale = <span class="keyword">this</span>.localeResolver.resolveLocale(request);</div><div class="line">	response.setLocale(locale);</div><div class="line"></div><div class="line">	View view;</div><div class="line">	<span class="keyword">if</span> (mv.isReference()) &#123;</div><div class="line">		<span class="comment">//View如果是引用类型，则需要调用resolveViewName使用ViewResolver得到实际的View</span></div><div class="line">		view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);</div><div class="line">		<span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"Could not resolve view with name '"</span> + mv.getViewName() +</div><div class="line">					<span class="string">"' in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// No need to lookup: the ModelAndView object contains the actual View object.</span></div><div class="line">		view = mv.getView();</div><div class="line">		<span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"ModelAndView ["</span> + mv + <span class="string">"] neither contains a view name nor a "</span> +</div><div class="line">					<span class="string">"View object in servlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">		logger.debug(<span class="string">"Rendering view ["</span> + view + <span class="string">"] in DispatcherServlet with name '"</span> + getServletName() + <span class="string">"'"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">try</span> &#123;</div><div class="line">	<span class="comment">//对页面进行具体渲染</span></div><div class="line">		view.render(mv.getModelInternal(), request, response);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</div><div class="line">			logger.debug(<span class="string">"Error rendering view ["</span> + view + <span class="string">"] in DispatcherServlet with name '"</span> +</div><div class="line">					getServletName() + <span class="string">"'"</span>, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">throw</span> ex;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面代码我们可以看出，processDispatchResult处理异常的方式是将相应的错误页面设置到View，并在其中的processHandlerException方法中用到了HandlerExceptionResolver。</p>
<p>渲染页面具体在render方法中执行，render中首先对response设置了Local，过程中使用到了LocalResolver，然后判断View如果是String类型则调用resolveViewName方法使用ViewResolver得到实际的View，最后调用view的render方法对页面进行具体的渲染，该过程使用到了ThemeResolver。</p>
<p>最后通过mappedHandler的triggerAfterCompletion方法触发Interceptor的afterCompletion方法。</p>
<p>至此doDispatcher的结构已经分析完毕，在上面我们还留下一个问题没有解决，那就是为什么Spring MVC对处理请求的思路与HttpServlet的将不同类型的请求路由到不同的方法进行处理的思路相反，将所有的请求合并到了processRequest方法中，这是因为Spring MVC将不同类型的请求用不同的Handler进行处理，但通过HandlerAdapter对Handler进行封装，以统一的适配器接口调用Handler，因而将所有的请求合并到了processRequest方法中。</p>
<p><strong>概括总结一下DispatcherServlet的处理过程：</strong><br>DispatcherServlet的处理请求入口方法是doService，但它没有直接进行具体处理，而是将具体处理交给了doDispatcher，而doDispatcher方法从顶层设计了整个请求处理的过程：</p>
<ol>
<li>根据request找到Handler</li>
<li>根据Handler找到对应的HandlerAdapter</li>
<li>用HandlerAdapter处理Handler</li>
<li>调用processRequestResult方法处理上面处理之后的结果（包括异常处理、渲染页面、触发Interceptor的afterCompletion方法）</li>
</ol>
<p>最后解释一下三个概念：HandlerMapping、Handler和HandlerAdapter。这三个概念的准确理解对于Spring MVC的学习非常重要。</p>
<ol>
<li>HandlerMapping，是用来查找Handler的，在Spring MVC中会处理很多请求，每个请求都需要一个Handler来处理，具体接收到一个请求后由HandlerMapping决定使用哪个Handler来处理。</li>
<li>Handler，也就是处理器，直接对应MVC中的C也就是Controller层，标注了@RequestMapping的所有方法都可以看成一个Handler</li>
<li>HandlerAdapter，因为Spring MVC中的Handler可以是任意的形式，但Servlet需要处理的方法的结构确实固定的，都是以request和response为参数，因而需要HandlerAdapter来让固定的Servlet处理方法调用灵活的Handler来进行具体处理。</li>
</ol>
<h1 id="doDispatcher流程"><a href="#doDispatcher流程" class="headerlink" title="doDispatcher流程"></a>doDispatcher流程</h1><p><img src="/img/doDispatcherProcess.png" alt="doDispatcher流程"><br>上图是doDispatcher的流程图，中间是doDispatcher的处理流程图，左边是Interceptor相关处理方法的调用位置，右边是doDispatcher方法处理过程中所涉及的组件。图中上半部分的处理请求对应着MVC的Controller即C层，下半部分的processRequestResult主要对应MVC中的View即V层，M层也就是Model贯穿于与整个过程中。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li>《看透Spring MVC 源代码分析与实践》</li>
<li>《Spring Reference》</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/" data-id="cit3wbfmn0005nworx1thuxqt" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/#ds-thread" class="article-comment-link">評論</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="Spring MVC处理请求过程(Spring MVC源码阅读系列之二)">
            &nbsp; | &nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/08/24/IOC容器和Dependency Injection模式/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">
        
          IOC容器和Dependency Injection模式
        
      </div>
    </a>
  
  
    <a href="/2016/08/18/Spring MVC的创建过程（SpringMVC源码阅读系列之一）/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">Spring MVC的创建过程(SpringMVC源码阅读系列之一)</div>
    </a>
  
</nav>

  
</article>


  <section id="comments">
    <div id="ds-thread" class="ds-thread" data-thread-key="2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/" data-title="Spring MVC处理请求过程(Spring MVC源码阅读系列之二)" data-url="localhost:4000/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/"></div>
  </section>


</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/07/设计模式系列之学习设计模式之由/">(no title)</a>
          </li>
        
          <li>
            <a href="/2016/09/07/设计模式系列之单例模式/">设计模式系列之单例模式</a>
          </li>
        
          <li>
            <a href="/2016/09/05/Tomcat处理请求过程（Tomcat源码阅读系列之四）/">Tomcat处理请求过程(Tomcat源码阅读系系列之四)</a>
          </li>
        
          <li>
            <a href="/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/">Tomcat的Session管理</a>
          </li>
        
          <li>
            <a href="/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/">eclipse&amp;Myeclipse&amp;Intellij Idea源码阅读快捷键</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分類</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java框架/">Java框架</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">歸檔</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 WoodyOilove<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
    
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260393587'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1260393587%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>

  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="返回頂部"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->


<!-- duoshuo start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"woodyoilove"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- duoshuo end -->


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
