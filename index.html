
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <title>WoodyOilove&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Record little growth and share littel growth">
<meta property="og:type" content="website">
<meta property="og:title" content="WoodyOilove's Blog">
<meta property="og:url" content="localhost:4000/index.html">
<meta property="og:site_name" content="WoodyOilove's Blog">
<meta property="og:description" content="Record little growth and share littel growth">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WoodyOilove's Blog">
<meta name="twitter:description" content="Record little growth and share littel growth">
  
  
  <link rel="stylesheet" href="/css/style.css">
  
    <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
  

</head>

<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <nav id="upper-nav" class="inner">
      <a id="main-nav-toggle" class="nav-icon"></a>
      <div class="sub-nav">
        
        
          <a id="nav-github" class="nav-icon" href="https://github.com/oilove"></a>
        
      </div>
    </nav>
    <div id="header-title">
      
        <h1 id="blog-title-wrap">
          <a href="/" id="blog-title">WoodyOilove&#39;s Blog</a>
        </h1>
      
    </div>
    <div id="contenedor">
      <ul class="cube">
        <li class="cara">H</li>
        <li class="cara"><svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="100" width="100" viewBox="-50 -50 200 200">
          <circle cx="50" cy="50" r="45" stroke-width="5" stroke="black" stroke-opacity="0.5" fill-opacity="0"></circle>
          <rect x="47.5" y="27.5" width="5" height="25" rx="2.5" ry="2.5" fill="black" fill-opacity="0.5" transform="rotate(330 50 50)"></rect>
          <rect x="48.5" y="16.5" width="3" height="35" rx="1.5" ry="1.5" fill="black" fill-opacity="0.5"></rect>
        </svg></li>
        <li class="cara">F</li>
        <li class="cara">O</li>
        <li class="cara">E</li>
        <li class="cara">N</li>
      </ul>
    </div>
    <nav id="main-nav">
      
        <a class="main-nav-link" href="/">Home</a>
      
        <a class="main-nav-link" href="/archives">Archives</a>
      
        <a class="main-nav-link" href="/about">About</a>
      
      <!--<a class="main-nav-link st-search-show-outputs">Search</a>-->
    </nav>
  </div>
</header>

    <div class="outer">
      <section id="main">
  
    <article id="post-设计模式系列之学习设计模式之由" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/09/07/设计模式系列之学习设计模式之由/" class="article-date">
  <time datetime="2016-09-06T16:00:00.000Z" itemprop="datePublished">2016-09-07</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/设计模式系列之学习设计模式之由/">设计模式系列之设计模式学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>为什么要学习设计模式，或许这个问题每个人都能够给予你很多理由，而笔者学习的理由主要有以下两点：</p>
<ol>
<li>学习设计模式是个人技术能力提高的途径。设计模式是很多优秀的前辈经验的积累，大都是一些相对优秀的解决方案，很多问题也是典型的、有代表性的问题。我们通过学习设计模式，可以学习到众多优秀前辈的经验，吸收和领会他们的设计思想，掌握他们解决问题的方法，这就相当于站在这些巨人的肩膀上，可以让我们个人的技术得到快速的提升。当然，学习设计模式也是有一定的困难，需要我们在理解的基础上，思考，应用，再思考，再应用，如此反复，方能真正掌握设计模式。</li>
<li>设计模式是解决某些特定问题的解决方案，当我们再次面对这些问题时，不用自己从头开始解决这些问题，复用这些解决方案即可。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/09/07/设计模式系列之学习设计模式之由/" data-id="cit3wbfnj000pnwor8u9qu6z6" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/09/07/设计模式系列之学习设计模式之由/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="设计模式系列之设计模式学习">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-设计模式系列之单例模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/09/07/设计模式系列之单例模式/" class="article-date">
  <time datetime="2016-09-06T16:00:00.000Z" itemprop="datePublished">2016-09-07</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/设计模式/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/07/设计模式系列之单例模式/">设计模式系列之单例模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>web应用程序使用配置文件配置应用环境参数是很常见的现象，既然使用了配置文件，那么程序中必然存在读取配置文件的内容的功能模块，下面我们来实现以下简单的读取配置文件的内容，例子中使用<code>properties</code>格式配置文件，因为使用Java读取<code>properties</code>格式配置文件比较简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.util.Properties;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</div><div class="line">	<span class="comment">//用于保存参数</span></div><div class="line">    <span class="keyword">private</span> String param1;</div><div class="line">    <span class="keyword">private</span> String param2;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParam1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> param1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParam1</span><span class="params">(String param1)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.param1 = param1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParam2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> param2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParam2</span><span class="params">(String param2)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.param2 = param2;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Config</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//读取配置文件</span></div><div class="line">        readConfig();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readConfig</span><span class="params">()</span> </span>&#123;</div><div class="line">        Properties p = <span class="keyword">new</span> Properties();</div><div class="line">        InputStream in = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            in = Config.class.getResourceAsStream(<span class="string">"Config.properties"</span>);</div><div class="line">            p.load(in);</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.param1 = p.getProperty(<span class="string">"param1"</span>);</div><div class="line">            <span class="keyword">this</span>.param2 = p.getProperty(<span class="string">"param2"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            System.out.println(<span class="string">"读取配置文件出错了，具体堆栈信息如下："</span>);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                in.close();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">//模拟客户端进行测试</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Config config = <span class="keyword">new</span> Config();</div><div class="line">        String param1 = config.getParam1();</div><div class="line">        String param2 = config.getParam2();</div><div class="line">        System.out.println(<span class="string">"param1: "</span>+param1);</div><div class="line">        System.out.println(<span class="string">"param2: "</span>+param2);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><em>注：上述代码需要在Config相同的包内添加配置文件，名称为Config.properties，简单示例如下：</em></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">param1 = 1</div><div class="line">param2 = 2</div></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">param1: 1</div><div class="line">param2: 2</div></pre></td></tr></table></figure>
<p>上面的实现非常简单，但是这样的做法有没有存在什么问题呢？</p>
<p>我们看看客户端使用这个类的地方，通过new一个Config实例来得到一个操作配置文件的对象，如果在系统运行中，有多个地方需要使用配置文件的内容时，这种方案就需要在多个地方都创建Config对象的实例，换句话说系统中存在多份相同的配置文件，若是配置文件比较大的话，这样就会严重浪费内存资源，这样的方案是不可取的。对于这种情况，显然我们需要在系统运行期间，只需要实例化这个类一次，即这个类只需要一个类实例，这种设想，需要我们下面即将提到的单例模式。</p>
        
          <p class="article-more-link">
            <a href="/2016/09/07/设计模式系列之单例模式/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/09/07/设计模式系列之单例模式/" data-id="cit3wbfnd000lnworzppcu4tt" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/09/07/设计模式系列之单例模式/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="设计模式系列之单例模式">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-Tomcat处理请求过程（Tomcat源码阅读系列之四）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/09/05/Tomcat处理请求过程（Tomcat源码阅读系列之四）/" class="article-date">
  <time datetime="2016-09-04T16:00:00.000Z" itemprop="datePublished">2016-09-05</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/05/Tomcat处理请求过程（Tomcat源码阅读系列之四）/">Tomcat处理请求过程(Tomcat源码阅读系系列之四)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>在前面的三篇文章中我们分别介绍了搭建Tomcat源码阅读环境、Tomcat的整体架构以及Tomat的启动和关闭过程，接着本文将分析Tomcat处理请求的过程。熟悉Java Socket编程的读者知道，Http的请求处理的一般过程如下：</p>
<ol>
<li><p>浏览器发送Http请求</p>
</li>
<li><p>服务器通过Socket读取请求数据</p>
</li>
<li><p>根据Http协议解析数据</p>
</li>
<li><p>调用后台服务完成后响应信息。</p>
</li>
</ol>
<p>下面我们一步步地来看Tomcat是如何实现以上的过程的。</p>
<h1 id="读取请求信息"><a href="#读取请求信息" class="headerlink" title="读取请求信息"></a>读取请求信息</h1><p>从Tomcat的生命周期这篇文章中，我们已经知道Tomcat是在<code>org.apache.tomcat.util.net.JIoEndpoint</code> 的内部类<code>Acceptor</code>线程对请求进行监听的，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> <span class="class"><span class="keyword">class</span> <span class="title">Acceptor</span> <span class="keyword">extends</span> <span class="title">AbstractEndpoint</span>.<span class="title">Acceptor</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">int</span> errorDelay = <span class="number">0</span>;</div><div class="line"></div><div class="line">    <span class="comment">//一直执行知道接收到关闭服务器的命令</span></div><div class="line">    <span class="keyword">while</span> (running) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//默认情况下是执行的，也就是说默认情况下paused是为false</span></div><div class="line">        <span class="keyword">while</span> (paused &amp;&amp; running) &#123;</div><div class="line">            state = AcceptorState.PAUSED;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">               Thread.sleep(<span class="number">50</span>);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            <span class="comment">// Ignore</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    	<span class="keyword">if</span> (!running) &#123;</div><div class="line">       	  <span class="keyword">break</span>;</div><div class="line">    	&#125;</div><div class="line">    	state = AcceptorState.RUNNING;</div><div class="line"></div><div class="line">    	<span class="keyword">try</span> &#123;</div><div class="line">       	   <span class="comment">//使用limitLatch限制最大连接数</span></div><div class="line">           <span class="comment">//1</span></div><div class="line">       	   countUpOrAwaitConnection();</div><div class="line"></div><div class="line">       	   Socket socket = <span class="keyword">null</span>;</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">             <span class="comment">// 接收到达的http请求，如果没有请求到达会阻塞该线程</span></div><div class="line">             <span class="comment">//2</span></div><div class="line">             socket = serverSocketFactory.acceptSocket(serverSocket);</div><div class="line">           &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</div><div class="line">              countDownConnection();</div><div class="line">              <span class="comment">// Introduce delay if necessary</span></div><div class="line">              errorDelay = handleExceptionWithDelay(errorDelay);</div><div class="line">              <span class="comment">// re-throw</span></div><div class="line">              <span class="keyword">throw</span> ioe;</div><div class="line">           &#125;</div><div class="line">       		<span class="comment">// Successful accept, reset the error delay</span></div><div class="line">      	   errorDelay = <span class="number">0</span>;</div><div class="line"></div><div class="line">       	   <span class="comment">// 设置Socket的配置信息，是否为长连接、发送窗口大小等</span></div><div class="line">           <span class="comment">//3</span></div><div class="line">           <span class="keyword">if</span> (running &amp;&amp; !paused &amp;&amp; setSocketOptions(socket)) &#123;</div><div class="line">             <span class="comment">//提交socket到相对应的processor线程池处理</span></div><div class="line">             <span class="comment">//4</span></div><div class="line">             <span class="keyword">if</span> (!processSocket(socket)) &#123;</div><div class="line">               countDownConnection();</div><div class="line">               <span class="comment">// Close socket right away</span></div><div class="line">               closeSocket(socket);</div><div class="line">             &#125;</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">               countDownConnection();</div><div class="line">               <span class="comment">// Close socket right away</span></div><div class="line">               closeSocket(socket);</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (IOException x) &#123;</div><div class="line">            <span class="keyword">if</span> (running) &#123;</div><div class="line">                log.error(sm.getString(<span class="string">"endpoint.accept.fail"</span>), x);</div><div class="line">            &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</div><div class="line">            <span class="keyword">if</span> (running) &#123;</div><div class="line">               log.error(sm.getString(<span class="string">"endpoint.accept.fail"</span>), npe);</div><div class="line">            &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">           ExceptionUtils.handleThrowable(t);</div><div class="line">           log.error(sm.getString(<span class="string">"endpoint.accept.fail"</span>), t);</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">    state = AcceptorState.ENDED;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">processSocket</span><span class="params">(Socket socket)</span> </span>&#123;</div><div class="line">    <span class="comment">// Process the request from this socket</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      <span class="comment">//Socket包装类，添加一些socket属性</span></div><div class="line">      SocketWrapper&lt;Socket&gt; wrapper = <span class="keyword">new</span> SocketWrapper&lt;Socket&gt;(socket);</div><div class="line">      wrapper.setKeepAliveLeft(getMaxKeepAliveRequests());</div><div class="line">      <span class="comment">// During shutdown, executor may be null - avoid NPE</span></div><div class="line">      <span class="keyword">if</span> (!running) &#123;</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">      getExecutor().execute(<span class="keyword">new</span> SocketProcessor(wrapper));</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException x) &#123;</div><div class="line">        log.warn(<span class="string">"Socket processing request was rejected for:"</span>+socket,x);</div><div class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        ExceptionUtils.handleThrowable(t);</div><div class="line">       <span class="comment">// This means we got an OOM or similar creating a thread, or that</span></div><div class="line">       <span class="comment">// the pool and its queue are full</span></div><div class="line">       log.error(sm.getString(<span class="string">"endpoint.process.fail"</span>), t);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码虽然比较长，但实际上主要做了上面标注的四件事：</p>
<ol>
<li>检查是否已经达到了最大连接数，没有则占用一个连接数</li>
<li>调用ServerSocket的accept()方法接收到达的请求，如果没有请求到达，则阻塞线程</li>
<li>设置Socket的配置参数，如是否为长连接等</li>
<li>提交socket给相应的processor进行处理。</li>
</ol>
<p>接下来我们再来看看Tomcat是如何对Http协议进行解析的，首先我们先来看看<code>SocketProcessor#run</code>方法，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">boolean</span> launch = <span class="keyword">false</span>;</div><div class="line">   <span class="keyword">synchronized</span> (socket) &#123;</div><div class="line">     <span class="keyword">try</span> &#123;</div><div class="line">       SocketState state = SocketState.OPEN;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">         <span class="comment">// SSL handshake</span></div><div class="line">         serverSocketFactory.handshake(socket.getSocket());</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            ExceptionUtils.handleThrowable(t);</div><div class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</div><div class="line">              log.debug(sm.getString(<span class="string">"endpoint.err.handshake"</span>), t);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// Tell to close the socket</span></div><div class="line">            state = SocketState.CLOSED;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((state != SocketState.CLOSED)) &#123;</div><div class="line">           <span class="keyword">if</span> (status == <span class="keyword">null</span>) &#123;</div><div class="line">              <span class="comment">//1，处理处理请求</span></div><div class="line">              state = handler.process(socket, SocketStatus.OPEN);</div><div class="line">           &#125; <span class="keyword">else</span> &#123;</div><div class="line">              state = handler.process(socket,status);</div><div class="line">           &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (state == SocketState.CLOSED) &#123;</div><div class="line">           <span class="comment">// Close socket</span></div><div class="line">           <span class="keyword">if</span> (log.isTraceEnabled()) &#123;</div><div class="line">             log.trace(<span class="string">"Closing socket:"</span>+socket);</div><div class="line">           &#125;</div><div class="line">           countDownConnection();</div><div class="line">           <span class="keyword">try</span> &#123;</div><div class="line">               socket.getSocket().close();</div><div class="line">           &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">               <span class="comment">// Ignore</span></div><div class="line">           &#125;</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.OPEN ||</div><div class="line">                    state == SocketState.UPGRADING  ||</div><div class="line">                    state == SocketState.UPGRADED)&#123;</div><div class="line">                  socket.setKeptAlive(<span class="keyword">true</span>);</div><div class="line">                  socket.access();</div><div class="line">                  launch = <span class="keyword">true</span>;</div><div class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SocketState.LONG) &#123;</div><div class="line">                 socket.access();</div><div class="line">                 waitingRequests.add(socket);</div><div class="line">         &#125;</div><div class="line">     &#125; <span class="keyword">finally</span> &#123;</div><div class="line">          <span class="keyword">if</span> (launch) &#123;</div><div class="line">              <span class="keyword">try</span> &#123;</div><div class="line">                getExecutor().execute(<span class="keyword">new</span> SocketProcessor(socket, SocketStatus.OPEN));</div><div class="line">              &#125; <span class="keyword">catch</span> (RejectedExecutionException x) &#123;</div><div class="line">                  log.warn(<span class="string">"Socket reprocessing request was rejected for:"</span>+socket,x);</div><div class="line">                  <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="comment">//unable to handle connection at this time</span></div><div class="line">                    handler.process(socket, SocketStatus.DISCONNECT);</div><div class="line">                  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                     countDownConnection();</div><div class="line">                  &#125;</div><div class="line">               &#125; <span class="keyword">catch</span> (NullPointerException npe) &#123;</div><div class="line">                    <span class="keyword">if</span> (running) &#123;</div><div class="line">                      log.error(sm.getString(<span class="string">"endpoint.launch.fail"</span>),npe);</div><div class="line">                    &#125;</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line">   socket = <span class="keyword">null</span>;</div><div class="line">   <span class="comment">// Finish up this request</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码核心的标注1的代码，调用handler的process方法处理socket，我们继续debug进去发现，调用了<code>AbstractProtocol$Http11ConnectionHandler#process</code>方法，最终调用<code>Http11Processor#process</code>方法对socket进行处理，因此下面我们来看看<code>Http11Processor#process</code>方法，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> SocketState <span class="title">process</span><span class="params">(SocketWrapper&lt;S&gt; socketWrapper)</span></span></div><div class="line">    <span class="keyword">throws</span> IOException &#123;</div><div class="line">    RequestInfo rp = request.getRequestProcessor();</div><div class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_PARSE);</div><div class="line"></div><div class="line">    <span class="comment">// Setting up the I/O</span></div><div class="line">    setSocketWrapper(socketWrapper);</div><div class="line">    getInputBuffer().init(socketWrapper, endpoint);</div><div class="line">    getOutputBuffer().init(socketWrapper, endpoint);</div><div class="line"></div><div class="line">    <span class="comment">// Flags</span></div><div class="line">    error = <span class="keyword">false</span>;</div><div class="line">    keepAlive = <span class="keyword">true</span>;</div><div class="line">    comet = <span class="keyword">false</span>;</div><div class="line">    openSocket = <span class="keyword">false</span>;</div><div class="line">    sendfileInProgress = <span class="keyword">false</span>;</div><div class="line">    readComplete = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (endpoint.getUsePolling()) &#123;</div><div class="line">        keptAlive = <span class="keyword">false</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        keptAlive = socketWrapper.isKeptAlive();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (disableKeepAlive()) &#123;</div><div class="line">        socketWrapper.setKeepAliveLeft(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (!error &amp;&amp; keepAlive &amp;&amp; !comet &amp;&amp; !isAsync() &amp;&amp;</div><div class="line">            upgradeInbound == <span class="keyword">null</span> &amp;&amp; !endpoint.isPaused()) &#123;</div><div class="line"></div><div class="line">        <span class="comment">//1解析请求头</span></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            setRequestLineReadTimeout();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (!getInputBuffer().parseRequestLine(keptAlive)) &#123;</div><div class="line">                <span class="keyword">if</span> (handleIncompleteRequestLineRead()) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (endpoint.isPaused()) &#123;</div><div class="line">                <span class="comment">// 503 - Service unavailable</span></div><div class="line">                response.setStatus(<span class="number">503</span>);</div><div class="line">                error = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// Make sure that connectors that are non-blocking during</span></div><div class="line">                <span class="comment">// header processing (NIO) only set the start time the first</span></div><div class="line">                <span class="comment">// time a request is processed.</span></div><div class="line">                <span class="keyword">if</span> (request.getStartTime() &lt; <span class="number">0</span>) &#123;</div><div class="line">                    request.setStartTime(System.currentTimeMillis());</div><div class="line">                &#125;</div><div class="line">                keptAlive = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// Set this every time in case limit has been changed via JMX</span></div><div class="line">                request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());</div><div class="line">                <span class="comment">// Currently only NIO will ever return false here</span></div><div class="line">                <span class="keyword">if</span> (!getInputBuffer().parseHeaders()) &#123;</div><div class="line">                    <span class="comment">// We've read part of the request, don't recycle it</span></div><div class="line">                    <span class="comment">// instead associate it with the socket</span></div><div class="line">                    openSocket = <span class="keyword">true</span>;</div><div class="line">                    readComplete = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (!disableUploadTimeout) &#123;</div><div class="line">                    setSocketTimeout(connectionUploadTimeout);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</div><div class="line">                getLog().debug(</div><div class="line">                    sm.getString(<span class="string">"http11processor.header.parse"</span>), e);</div><div class="line">            &#125;</div><div class="line">            error = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">            ExceptionUtils.handleThrowable(t);</div><div class="line">            UserDataHelper.Mode logMode = userDataHelper.getNextMode();                <span class="keyword">if</span> (logMode != <span class="keyword">null</span>) &#123;</div><div class="line">                String message = sm.getString(</div><div class="line">                        <span class="string">"http11processor.header.parse"</span>);</div><div class="line">                <span class="keyword">switch</span> (logMode) &#123;</div><div class="line">                    <span class="keyword">case</span> INFO_THEN_DEBUG:</div><div class="line">                        message += sm.getString(</div><div class="line">                                <span class="string">"http11processor.fallToDebug"</span>);</div><div class="line">                        <span class="comment">//$FALL-THROUGH$</span></div><div class="line">                    <span class="keyword">case</span> INFO:</div><div class="line">                        getLog().info(message);</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    <span class="keyword">case</span> DEBUG:</div><div class="line">                        getLog().debug(message);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 400 - Bad Request</span></div><div class="line">            response.setStatus(<span class="number">400</span>);</div><div class="line">            adapter.log(request, response, <span class="number">0</span>);</div><div class="line">            error = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!error) &#123;</div><div class="line">            <span class="comment">// Setting up filters, and parse some request headers</span></div><div class="line">            rp.setStage(org.apache.coyote.Constants.STAGE_PREPARE);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//2设置filter，请求信息编码</span></div><div class="line">                prepareRequest();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                ExceptionUtils.handleThrowable(t);</div><div class="line">                <span class="keyword">if</span> (getLog().isDebugEnabled()) &#123;</div><div class="line">                    getLog().debug(sm.getString(</div><div class="line">                        <span class="string">"http11processor.request.prepare"</span>), t);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// 400 - Internal Server Error</span></div><div class="line">                response.setStatus(<span class="number">400</span>);</div><div class="line">                adapter.log(request, response, <span class="number">0</span>);</div><div class="line">                error = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (maxKeepAliveRequests == <span class="number">1</span>) &#123;</div><div class="line">            keepAlive = <span class="keyword">false</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (maxKeepAliveRequests &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">            socketWrapper.decrementKeepAlive() &lt;= <span class="number">0</span>) &#123;</div><div class="line">            keepAlive = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//3 adaptor调用相应的Servlet处理请求</span></div><div class="line">        <span class="keyword">if</span> (!error) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                rp.setStage(org.apache.coyote.Constants.STAGE_SERVICE);</div><div class="line">                adapter.service(request, response);</div><div class="line">                <span class="comment">// Handle when the response was committed before a serious</span></div><div class="line">                <span class="comment">// error occurred.  Throwing a ServletException should both</span></div><div class="line">                <span class="comment">// set the status to 500 and set the errorException.</span></div><div class="line">                <span class="comment">// If we fail here, then the response is likely already</span></div><div class="line">                <span class="comment">// committed, so we can't try and set headers.</span></div><div class="line">                <span class="keyword">if</span>(keepAlive &amp;&amp; !error) &#123; <span class="comment">// Avoid checking twice.</span></div><div class="line">                    error = response.getErrorException() != <span class="keyword">null</span> ||</div><div class="line">                        (!isAsync() &amp;&amp;</div><div class="line">                        statusDropsConnection(response.getStatus()));</div><div class="line">                &#125;</div><div class="line">                setCometTimeouts(socketWrapper);</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedIOException e) &#123;</div><div class="line">                error = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (HeadersTooLargeException e) &#123;</div><div class="line">                error = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">// The response should not have been committed but check it</span></div><div class="line">                <span class="comment">// anyway to be safe</span></div><div class="line">                <span class="keyword">if</span> (!response.isCommitted()) &#123;</div><div class="line">                    response.reset();</div><div class="line">                    response.setStatus(<span class="number">500</span>);</div><div class="line">                    response.setHeader(<span class="string">"Connection"</span>, <span class="string">"close"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">                ExceptionUtils.handleThrowable(t);</div><div class="line">                getLog().error(sm.getString(</div><div class="line">                        <span class="string">"http11processor.request.process"</span>), t);</div><div class="line">                <span class="comment">// 500 - Internal Server Error</span></div><div class="line">                response.setStatus(<span class="number">500</span>);</div><div class="line">                adapter.log(request, response, <span class="number">0</span>);</div><div class="line">                error = <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//4 完成请求后，响应请求等处理</span></div><div class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_ENDINPUT);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet) &#123;</div><div class="line">            <span class="keyword">if</span> (error) &#123;</div><div class="line">                <span class="comment">// If we know we are closing the connection, don't drain</span></div><div class="line">                <span class="comment">// input. This way uploading a 100GB file doesn't tie up the</span></div><div class="line">                <span class="comment">// thread if the servlet has rejected it.</span></div><div class="line">                getInputBuffer().setSwallowInput(<span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">            endRequest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_ENDOUTPUT);</div><div class="line"></div><div class="line">        <span class="comment">// If there was an error, make sure the request is counted as</span></div><div class="line">        <span class="comment">// and error, and update the statistics counter</span></div><div class="line">        <span class="keyword">if</span> (error) &#123;</div><div class="line">            response.setStatus(<span class="number">500</span>);</div><div class="line">        &#125;</div><div class="line">        request.updateCounters();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isAsync() &amp;&amp; !comet || error) &#123;</div><div class="line">            getInputBuffer().nextRequest();</div><div class="line">            getOutputBuffer().nextRequest();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!disableUploadTimeout) &#123;</div><div class="line">            <span class="keyword">if</span>(endpoint.getSoTimeout() &gt; <span class="number">0</span>) &#123;</div><div class="line">                setSocketTimeout(endpoint.getSoTimeout());</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                setSocketTimeout(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        rp.setStage(org.apache.coyote.Constants.STAGE_KEEPALIVE);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (breakKeepAliveLoop(socketWrapper)) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    rp.setStage(org.apache.coyote.Constants.STAGE_ENDED);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (error || endpoint.isPaused()) &#123;</div><div class="line">        <span class="keyword">return</span> SocketState.CLOSED;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isAsync() || comet) &#123;</div><div class="line">           <span class="keyword">return</span> SocketState.LONG;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isUpgrade()) &#123;</div><div class="line">            <span class="keyword">return</span> SocketState.UPGRADING;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (sendfileInProgress) &#123;</div><div class="line">            <span class="keyword">return</span> SocketState.SENDFILE;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (openSocket) &#123;</div><div class="line">                <span class="keyword">if</span> (readComplete) &#123;</div><div class="line">                    <span class="keyword">return</span> SocketState.OPEN;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="keyword">return</span> SocketState.LONG;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">return</span> SocketState.CLOSED;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码比较长，但实际上该方法主要做了四件事：</p>
<ol>
<li>解析请求头信息</li>
<li>调用<code>prepareRequest</code> 方法在处理请求之前对请求做一些处理，如Filter、设置编码等，</li>
<li>调用adaptor调用对应的Servlet处理请求</li>
<li>调用<code>endrequest</code> 在完成请求后的相关处理，如响应信息等</li>
</ol>
<p>前两步的作用是从Socket中获取信息构建<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code> </p>
<p>下面我们来看看Tomcat是如何解析请求信息的。</p>
<h1 id="解析请求数据"><a href="#解析请求数据" class="headerlink" title="解析请求数据"></a>解析请求数据</h1><p>从上面我们已经知道Tomcat的解析请求数据的代码就如下几句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//设置读取请求行超时时间</span></div><div class="line">setRequestLineReadTimeout();</div><div class="line"><span class="comment">//1解析请求行</span></div><div class="line"><span class="keyword">if</span> (!getInputBuffer().parseRequestLine(keptAlive)) &#123;</div><div class="line">   <span class="keyword">if</span> (handleIncompleteRequestLineRead()) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">   &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (endpoint.isPaused()) &#123;</div><div class="line">   <span class="comment">// 503 - Service unavailable</span></div><div class="line">   response.setStatus(<span class="number">503</span>);</div><div class="line">   error = <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">   <span class="comment">// Make sure that connectors that are non-blocking during</span></div><div class="line">   <span class="comment">// header processing (NIO) only set the start time the first</span></div><div class="line">   <span class="comment">// time a request is processed.</span></div><div class="line">   <span class="keyword">if</span> (request.getStartTime() &lt; <span class="number">0</span>) &#123;</div><div class="line">      request.setStartTime(System.currentTimeMillis());</div><div class="line">   &#125;</div><div class="line">   keptAlive = <span class="keyword">true</span>;</div><div class="line">   <span class="comment">// Set this every time in case limit has been changed via JMX</span></div><div class="line">   request.getMimeHeaders().setLimit(endpoint.getMaxHeaderCount());</div><div class="line">  <span class="comment">// Currently only NIO will ever return false here</span></div><div class="line">   <span class="comment">//2 处理请求头</span></div><div class="line">   <span class="keyword">if</span> (!getInputBuffer().parseHeaders()) &#123;</div><div class="line">         <span class="comment">// We've read part of the request, don't recycle it</span></div><div class="line">         <span class="comment">// instead associate it with the socket</span></div><div class="line">         openSocket = <span class="keyword">true</span>;</div><div class="line">         readComplete = <span class="keyword">false</span>;</div><div class="line">         <span class="keyword">break</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (!disableUploadTimeout) &#123;</div><div class="line">      setSocketTimeout(connectionUploadTimeout);</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面的代码我们可以知道首先先解析请求行，再解析请求头的信息，请求头的信息存放在<code>MimeHeaders</code>中。到了这了有必要说明一下，请求行和请求体。我们来看下面的例子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">GET / HTTP/1.1</div><div class="line">Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</div><div class="line">Accept-Encoding:gzip, deflate, sdch</div><div class="line">Accept-Language:zh-CN,zh;q=0.8</div><div class="line">Cache-Control:max-age=0</div><div class="line">Connection:keep-alive</div><div class="line">DNT:1</div><div class="line">Host:localhost:8080</div><div class="line">Upgrade-Insecure-Requests:1</div><div class="line">User-Agent:Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.75 Safari/537.36</div></pre></td></tr></table></figure>
<p>在上面的Http协议get请求中，第一行就是请求行，其余的都是请求体，但需要注意的是HTTP协议的要求，请求行末尾必须是CRLF，而请求行与请求体之间必须使用空行隔开，而空行也必须包含CRLF。至于<code>parseRequestLine</code> 和 <code>parseHeaders</code>方法的分析，在此不作分析，有兴趣的可以自行阅读代码分析，需要注意其中了CR和LF的判断体现刚刚所说的HTTP协议的要求。接下来我们来看看adaptor是如何将请求转发的对应的Servlet的。</p>
<h1 id="Adaptor转发请求到Servlet"><a href="#Adaptor转发请求到Servlet" class="headerlink" title="Adaptor转发请求到Servlet"></a>Adaptor转发请求到Servlet</h1><p>在上面我们已经知道如何根据HTTP协议在Socket中解析出信息，并构建<code>org.apache.Request</code> 和 <code>org.apache.Response</code> 对象，通过Adaptor调用相应Servlet进行具体的处理，下面我们来看<code>CoyoteAdaptor#service</code>方法，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(org.apache.coyote.Request req,</span></span></div><div class="line">                        org.apache.coyote.Response res)</div><div class="line">    <span class="keyword">throws</span> Exception &#123;</div><div class="line">    </div><div class="line">    Request request = (Request) req.getNote(ADAPTER_NOTES);</div><div class="line">    Response response = (Response) res.getNote(ADAPTER_NOTES);</div><div class="line">	<span class="comment">//1，将org.apache.coyote.Request和org.apache.coyote.Response对象装换为org.apache.catalina.connector.Request和org.apache.catalina.connector.Response对象</span></div><div class="line">    <span class="keyword">if</span> (request == <span class="keyword">null</span>) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// Create objects</span></div><div class="line">        request = connector.createRequest();</div><div class="line">        request.setCoyoteRequest(req);</div><div class="line">        response = connector.createResponse();</div><div class="line">        response.setCoyoteResponse(res);</div><div class="line"></div><div class="line">        <span class="comment">// Link objects</span></div><div class="line">        request.setResponse(response);</div><div class="line">        response.setRequest(request);</div><div class="line"></div><div class="line">        <span class="comment">// Set as notes</span></div><div class="line">        req.setNote(ADAPTER_NOTES, request);</div><div class="line">        res.setNote(ADAPTER_NOTES, response);</div><div class="line"></div><div class="line">        <span class="comment">// Set query string encoding</span></div><div class="line">        req.getParameters().setQueryStringEncoding</div><div class="line">            (connector.getURIEncoding());</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (connector.getXpoweredBy()) &#123;</div><div class="line">        response.addHeader(<span class="string">"X-Powered-By"</span>, POWERED_BY);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span> comet = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">boolean</span> async = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line"></div><div class="line">        <span class="comment">// Parse and set Catalina and configuration specific</span></div><div class="line">        <span class="comment">// request parameters</span></div><div class="line">        req.getRequestProcessor().setWorkerThreadName(Thread.currentThread().getName());</div><div class="line">        <span class="comment">//2 根据request和找到对应的Host、Context、和Wrapper对象，即找到对应的Servlet</span></div><div class="line">        <span class="keyword">boolean</span> postParseSuccess = postParseRequest(req, request, res, response);</div><div class="line">        <span class="keyword">if</span> (postParseSuccess) &#123;</div><div class="line">            <span class="comment">//check valves if we support async</span></div><div class="line">            request.setAsyncSupported(connector.getService().getContainer().getPipeline().isAsyncSupported());</div><div class="line">            <span class="comment">//3 调用相应的容器进行处理</span></div><div class="line">            connector.getService().getContainer().getPipeline().getFirst().invoke(request, response);</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (request.isComet()) &#123;</div><div class="line">                <span class="keyword">if</span> (!response.isClosed() &amp;&amp; !response.isError()) &#123;</div><div class="line">                    <span class="keyword">if</span> (request.getAvailable() || (request.getContentLength() &gt; <span class="number">0</span> &amp;&amp; (!request.isParametersParsed()))) &#123;</div><div class="line">                        <span class="comment">// Invoke a read event right away if there are available bytes</span></div><div class="line">                        <span class="keyword">if</span> (event(req, res, SocketStatus.OPEN)) &#123;</div><div class="line">                            comet = <span class="keyword">true</span>;</div><div class="line">                            res.action(ActionCode.COMET_BEGIN, <span class="keyword">null</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        comet = <span class="keyword">true</span>;</div><div class="line">                        res.action(ActionCode.COMET_BEGIN, <span class="keyword">null</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// Clear the filter chain, as otherwise it will not be reset elsewhere</span></div><div class="line">                    <span class="comment">// since this is a Comet request</span></div><div class="line">                    request.setFilterChain(<span class="keyword">null</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        AsyncContextImpl asyncConImpl = (AsyncContextImpl)request.getAsyncContext();</div><div class="line">        <span class="keyword">if</span> (asyncConImpl != <span class="keyword">null</span>) &#123;</div><div class="line">            async = <span class="keyword">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!comet) &#123;</div><div class="line">            request.finishRequest();</div><div class="line">            response.finishResponse();</div><div class="line">            <span class="keyword">if</span> (postParseSuccess &amp;&amp;</div><div class="line">                request.getMappingData().context != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// Log only if processing was invoked.</span></div><div class="line">                <span class="comment">// If postParseRequest() failed, it has already logged it.</span></div><div class="line">                <span class="comment">// If context is null this was the start of a comet request</span></div><div class="line">                <span class="comment">// that failed and has already been logged.</span></div><div class="line">                ((Context) request.getMappingData().context).logAccess(</div><div class="line">                        request, response,</div><div class="line">                        System.currentTimeMillis() - req.getStartTime(),</div><div class="line">                        <span class="keyword">false</span>);</div><div class="line">            &#125;</div><div class="line">            req.action(ActionCode.POST_REQUEST , <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">        <span class="comment">// Ignore</span></div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        req.getRequestProcessor().setWorkerThreadName(<span class="keyword">null</span>);</div><div class="line">        <span class="comment">// Recycle the wrapper request and response</span></div><div class="line">        <span class="keyword">if</span> (!comet &amp;&amp; !async) &#123;</div><div class="line">            request.recycle();</div><div class="line">            response.recycle();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Clear converters so that the minimum amount of memory</span></div><div class="line">            <span class="comment">// is used by this processor</span></div><div class="line">            request.clearEncoders();</div><div class="line">            response.clearEncoders();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码比较长，笔者标注了主流程的代码，下面我们逐一分析标注的代码：</p>
<ol>
<li>标注1的代码是将<code>org.apache.coyote.Request</code>和<code>org.apache.coyote.Response</code>对象装换为<code>org.apache.catalina.connector.Request</code>和<code>org.apache.catalina.connector.Response</code>对象,其中coyote包中的Request仅仅只是包含了解析出来的http协议的数据，而connector包中的Reqeust才是真正Servlet容器中的HttpservletRequest，里面包含了完成请求所需要的host、context和wrapper信息。</li>
<li>标注2调用<code>postParseRequest</code>方法，这个方法做了很多事，但主要都是为了根据request找到对应的Host、Context和Wrapper对象，换句话说就是找到处理请求的Servlet。</li>
<li>标注3的代码将Request通过Pipeline机制链式传递给最终的Servlet进行处理。</li>
</ol>
<p>至此我们已经从整体上理解了<code>org.apache.connector.CoyoteAdaptor#service</code> 方法的主要步骤，接下来我们来具体分析每一步所做的事，第一步比较简单，大家可以自行进行阅读，在此不作说明，主要来看看第2、3步。</p>
<p>首先我们来看看第2步，即<code>postParseRequest</code> 方法，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">postParseRequest</span><span class="params">(org.apache.coyote.Request req,</span></span></div><div class="line">                                       Request request,</div><div class="line">                                       org.apache.coyote.Response res,</div><div class="line">                                       Response response)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line"></div><div class="line">    <span class="comment">//省略了请求相关的参数的处理，为了下面查找对应的Context</span></div><div class="line"></div><div class="line">    <span class="keyword">while</span> (mapRequired) &#123;</div><div class="line">        <span class="keyword">if</span> (version != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// Once we have a version - that is it</span></div><div class="line">            mapRequired = <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 根据serverName和decodeURI查找对应的Context，和Wapper</span></div><div class="line">        connector.getMapper().map(serverName, decodedURI, version,</div><div class="line">                                    request.getMappingData());</div><div class="line">       <span class="comment">//获取context</span></div><div class="line">        request.setContext((Context) request.getMappingData().context);</div><div class="line">       <span class="comment">//获取Wrapper</span></div><div class="line">        request.setWrapper((Wrapper) request.getMappingData().wrapper);</div><div class="line"></div><div class="line">        <span class="comment">//此处省略了session等处理的代码</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//省略了转发处理，filter方法处理的代码</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们通过进一步分析查看<code>connector.getMapper.map</code>方法，知道该方法最终是在Mapper中有序的<code>map</code>元素数组中查找相应的Context和Wrapper，并保存到<code>org.apache.tomcat.util.http.mapper.MappingData</code>类型的属性中，执行完map方法后，再从MappingData中获取Context和Wrapper。</p>
<p>接着我们来分析第3步，这一步通过pipeline链式调用机制，最终调用了Servlet对象，而对于pipeline，其实是运用了责任链设计模式，它将各个阀门链接起来，然后一步步调用。阀门的主要来源有以下两个：</p>
<ol>
<li><code>conf/server.xml</code>文件中配置的<code>Value</code></li>
<li>每个容器的构造器中初始化的自己阀门,即每个容器都有一个对应的阀门对象，如<code>StandardEngine</code> 对应<code>StandardEngineValue</code>。</li>
</ol>
<p>通过debug跟踪代码，我们可以得到如下一个调用链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StandardEngineValue#invoke</div><div class="line">-&gt;AccessLogValue#invoke</div><div class="line">--&gt;ErrorReportValue#invoke</div><div class="line">---&gt;StandardHostValue#invoke</div><div class="line">----&gt;StandardContextValue#invoke</div><div class="line">-----&gt;StandardWrapperValue#invoke</div></pre></td></tr></table></figure>
<p>从上面我们知道最终调用<code>StandardWrapperValue#invoke</code> 方法，我们来看看<code>StandardWrapperValue#invoke</code> 方法，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Request request, Response response)</span></span></div><div class="line">       <span class="keyword">throws</span> IOException, ServletException &#123;</div><div class="line"></div><div class="line">       <span class="comment">// Initialize local variables we may need</span></div><div class="line">       <span class="keyword">boolean</span> unavailable = <span class="keyword">false</span>;</div><div class="line">       Throwable throwable = <span class="keyword">null</span>;</div><div class="line">       <span class="comment">// This should be a Request attribute...</span></div><div class="line">       <span class="keyword">long</span> t1=System.currentTimeMillis();</div><div class="line">       requestCount++;</div><div class="line">       StandardWrapper wrapper = (StandardWrapper) getContainer();</div><div class="line">       Servlet servlet = <span class="keyword">null</span>;</div><div class="line">       Context context = (Context) wrapper.getParent();</div><div class="line">       </div><div class="line">       <span class="comment">// 检查应用是否被标记为不可用</span></div><div class="line">       <span class="keyword">if</span> (!context.getState().isAvailable()) &#123;</div><div class="line">           response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</div><div class="line">                          sm.getString(<span class="string">"standardContext.isUnavailable"</span>));</div><div class="line">           unavailable = <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// 检查Servelt是否标记为不可用</span></div><div class="line">       <span class="keyword">if</span> (!unavailable &amp;&amp; wrapper.isUnavailable()) &#123;</div><div class="line">           container.getLogger().info(sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</div><div class="line">                   wrapper.getName()));</div><div class="line">           <span class="keyword">long</span> available = wrapper.getAvailable();</div><div class="line">           <span class="keyword">if</span> ((available &gt; <span class="number">0L</span>) &amp;&amp; (available &lt; Long.MAX_VALUE)) &#123;</div><div class="line">               response.setDateHeader(<span class="string">"Retry-After"</span>, available);</div><div class="line">               response.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE,</div><div class="line">                       sm.getString(<span class="string">"standardWrapper.isUnavailable"</span>,</div><div class="line">                               wrapper.getName()));</div><div class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (available == Long.MAX_VALUE) &#123;</div><div class="line">               response.sendError(HttpServletResponse.SC_NOT_FOUND,</div><div class="line">                       sm.getString(<span class="string">"standardWrapper.notFound"</span>,</div><div class="line">                               wrapper.getName()));</div><div class="line">           &#125;</div><div class="line">           unavailable = <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//1 产生一个Servelt实例处理请求</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">if</span> (!unavailable) &#123;</div><div class="line">               servlet = wrapper.allocate();</div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (UnavailableException e) &#123;</div><div class="line">           <span class="comment">//省略异常处理代码</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">// Identify if the request is Comet related now that the servlet has been allocated</span></div><div class="line">       <span class="keyword">boolean</span> comet = <span class="keyword">false</span>;</div><div class="line">       <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> CometProcessor &amp;&amp; request.getAttribute(</div><div class="line">               Globals.COMET_SUPPORTED_ATTR) == Boolean.TRUE) &#123;</div><div class="line">           comet = <span class="keyword">true</span>;</div><div class="line">           request.setComet(<span class="keyword">true</span>);</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       MessageBytes requestPathMB = request.getRequestPathMB();</div><div class="line">       DispatcherType dispatcherType = DispatcherType.REQUEST;</div><div class="line">       <span class="keyword">if</span> (request.getDispatcherType()==DispatcherType.ASYNC) dispatcherType = DispatcherType.ASYNC; </div><div class="line">       request.setAttribute(Globals.DISPATCHER_TYPE_ATTR,dispatcherType);</div><div class="line">       request.setAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR,</div><div class="line">               requestPathMB);</div><div class="line">       <span class="comment">// 创建了过滤器filter链</span></div><div class="line">       ApplicationFilterFactory factory =</div><div class="line">           ApplicationFilterFactory.getInstance();</div><div class="line">       ApplicationFilterChain filterChain =</div><div class="line">           factory.createFilterChain(request, wrapper, servlet);</div><div class="line">       </div><div class="line">       <span class="comment">// Reset comet flag value after creating the filter chain</span></div><div class="line">       request.setComet(<span class="keyword">false</span>);</div><div class="line">       <span class="comment">//2 调用filter链</span></div><div class="line">       <span class="comment">// <span class="doctag">NOTE:</span> This also calls the servlet's service() method</span></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           <span class="keyword">if</span> ((servlet != <span class="keyword">null</span>) &amp;&amp; (filterChain != <span class="keyword">null</span>)) &#123;</div><div class="line">               <span class="comment">// Swallow output if needed</span></div><div class="line">               <span class="keyword">if</span> (context.getSwallowOutput()) &#123;</div><div class="line">                   <span class="keyword">try</span> &#123;</div><div class="line">                       SystemLogHandler.startCapture();</div><div class="line">                       <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</div><div class="line">                           <span class="comment">//TODO SERVLET3 - async</span></div><div class="line">                           ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch(); </div><div class="line">                       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comet) &#123;</div><div class="line">                           filterChain.doFilterEvent(request.getEvent());</div><div class="line">                           request.setComet(<span class="keyword">true</span>);</div><div class="line">                       &#125; <span class="keyword">else</span> &#123;</div><div class="line">                           filterChain.doFilter(request.getRequest(), </div><div class="line">                                   response.getResponse());</div><div class="line">                       &#125;</div><div class="line">                   &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                       String log = SystemLogHandler.stopCapture();</div><div class="line">                       <span class="keyword">if</span> (log != <span class="keyword">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                           context.getLogger().info(log);</div><div class="line">                       &#125;</div><div class="line">                   &#125;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">if</span> (request.isAsyncDispatching()) &#123;</div><div class="line">                       <span class="comment">//TODO SERVLET3 - async</span></div><div class="line">                       ((AsyncContextImpl)request.getAsyncContext()).doInternalDispatch();</div><div class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comet) &#123;</div><div class="line">                       request.setComet(<span class="keyword">true</span>);</div><div class="line">                       filterChain.doFilterEvent(request.getEvent());</div><div class="line">                   &#125; <span class="keyword">else</span> &#123;</div><div class="line">                       filterChain.doFilter</div><div class="line">                           (request.getRequest(), response.getResponse());</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           &#125;</div><div class="line">       &#125; <span class="keyword">catch</span> (ClientAbortException e) &#123;</div><div class="line">           <span class="comment">//省略异常处理代码</span></div><div class="line">       &#125;</div><div class="line"></div><div class="line">       <span class="comment">//省略释放servlet实例和FilterChain代码</span></div><div class="line"></div><div class="line"></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>我们来分析一个上面标注的地方：</p>
<ol>
<li>标注1的代码实例化了Servlet对象，在实例化的过程中使用了Java双检查锁的机制来实现单实例</li>
<li>标注2的代码调用了Servlet的过滤器链，首先在根据filterConfig取到的web.xml文件中配置的filter，一个个调用，最终调用Servlet的service方法。</li>
</ol>
<p>经过上面的分析我们已经基本了解Tomcat请求解析的流程，现总结如下：</p>
<blockquote>
<p>Tomcat通过acceptor线程监听到到达的Http请求后，对socket进行了包装成<code>SocketProcessor</code>，提交给线程池进行处理，而<code>SocketProcessor#run</code> 最终调用了<code>Http11Processor#process</code>方法对socket进行以下处理：</p>
<ol>
<li>解析请求行和请求头的信息</li>
<li>调用prepareRequest 方法在处理请求之前对请求做一些处理，如Filter、请求编码处理等，</li>
<li>通过adaptor调用对应的Servlet处理请求，其调用过程如下：<ol>
<li>首先根据请求的URI和ServerName，从<code>Connector.Mapper</code> 的有序map数组中获取Context和Wrapper并保存到<code>org.apache.tomcat.util.http.mapper.MappingData</code>类型的属性中,接着再从<code>MappingData</code> 中获取Context和Wrapper</li>
<li>通过<code>pipeline</code> 调用机制，从<code>StandardEngineValue#invoke</code>开始，最终调用<code>StandardWrapperValue#invoke</code>，即调用对应的Servlet</li>
<li><code>StandardWrapperValue#invoke</code> 方法会使用Java双检查锁机制创建 <code>Servlet</code> 实例，然后创建<code>FilterChain</code>，调用 <code>FilterChain</code> 的<code>doFilter</code>，并在该方法中调用<code>Servlet</code>的 <code>service</code> 方法</li>
</ol>
</li>
<li>调用endrequest 在完成请求后的相关处理。</li>
</ol>
</blockquote>
<p>[^注：]: 本博客只是笔者对于Tomcat请求处理分析的过程，可能存在错误，欢迎留言或者Email指出，Email地址: woodyoilovecn@gmail.com,同时对于请求处理过程的一些过程并没有进行深入地挖掘，有兴趣的也可以Email一起交流讨论。</p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/09/05/Tomcat处理请求过程（Tomcat源码阅读系列之四）/" data-id="cit3wbfn3000cnworsg6wnzkb" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/09/05/Tomcat处理请求过程（Tomcat源码阅读系列之四）/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="Tomcat处理请求过程(Tomcat源码阅读系系列之四)">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-Tomcat的Session管理（Tomcat源码阅读系列之五）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/" class="article-date">
  <time datetime="2016-09-04T16:00:00.000Z" itemprop="datePublished">2016-09-05</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Tomcat/">Tomcat</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/">Tomcat的Session管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面几篇我们分析Tomcat的整体架构、生命周期、Tomcat请求处理过程，本篇文章我们将来分析一下Tomcat的Session的创建和销毁过程。</p>
        
          <p class="article-more-link">
            <a href="/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/" data-id="cit3wbfnb000inworxyqwv5x1" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="Tomcat的Session管理">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-eclipse&amp;Myeclipse&amp;Intellij Idea源码阅读快捷键" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/" class="article-date">
  <time datetime="2016-08-26T16:00:00.000Z" itemprop="datePublished">2016-08-27</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/开发工具/">开发工具</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/">eclipse&amp;Myeclipse&amp;Intellij Idea源码阅读快捷键</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>“工若善其事，必先利其器”，掌握一定的快捷键将更有利于我们阅读代码，更方便地理清代码的结构，下面笔者将分享在eclipse&amp;Myeclipse和Intellij Idea这三个IDE中阅读源码时常用到的快捷键。</p>
        
          <p class="article-more-link">
            <a href="/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/" data-id="cit3wbfng000mnworb54roklz" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="eclipse&amp;Myeclipse&amp;Intellij Idea源码阅读快捷键">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-IOC容器和Dependency Injection模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/24/IOC容器和Dependency Injection模式/" class="article-date">
  <time datetime="2016-08-23T16:00:00.000Z" itemprop="datePublished">2016-08-24</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java框架/">Java框架</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/24/IOC容器和Dependency Injection模式/">IOC容器和Dependency Injection模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>In the Java community there’s been a rush of lightweight containers that help to assemble components from different projects into a cohesive application. Underlying these containers is a common pattern to how they perform the wiring, a concept they refer under the very generic name of “Inversion of Control”. In this article I dig into how this pattern works, under the more specific name of “Dependency Injection”, and contrast it with the Service Locator alternative. The choice between them is less important than the principle of separating configuration from use.</p>
<p>One of the entertaining things about the enterprise Java world is the huge amount of activity in building alternatives to the mainstream J2EE technologies, much of it happening in open source. A lot of this is a reaction to the heavyweight complexity in the mainstream J2EE world, but much of it is also exploring alternatives and coming up with creative ideas. A common issue to deal with is how to wire together different elements: how do you fit together this web controller architecture with that database interface backing when they were built by different teams with little knowledge of each other. A number of frameworks have taken a stab at this problem, and several are branching out to provide a general capability to assemble components from different layers. These are often referred to as lightweight containers, examples include PicoContainer, and Spring.</p>
<p>Underlying these containers are a number of interesting design principles, things that go beyond both these specific containers and indeed the Java platform. Here I want to start exploring some of these principles. The examples I use are in Java, but like most of my writing the principles are equally applicable to other OO environments, particularly .NET.</p>
        
          <p class="article-more-link">
            <a href="/2016/08/24/IOC容器和Dependency Injection模式/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/24/IOC容器和Dependency Injection模式/" data-id="cit3wbfm20000nwor1oivvow5" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/24/IOC容器和Dependency Injection模式/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="IOC容器和Dependency Injection模式">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-Spring MVC处理请求过程（Spring MVC源码阅读系列之二）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/" class="article-date">
  <time datetime="2016-08-22T16:00:00.000Z" itemprop="datePublished">2016-08-23</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java框架/">Java框架</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/">Spring MVC处理请求过程(Spring MVC源码阅读系列之二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>本文是Spring MVC源码阅读系列的第二篇，在上一篇<a href="/2016/08/18/Spring%20MVC的创建过程（SpringMVC源码阅读系列之一）%2F">Spring MVC的创建过程</a>中我们介绍了SpringMVC的创建过程，本文讲给主要介绍当一个请求到达时，SpringMVC都做了些什么，即Spring MVC是如何处理请求的。</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从上一篇<a href="/2016/08/18/Spring%20MVC的创建过程（SpringMVC源码阅读系列之一）%2F">Spring MVC的创建过程</a> 我们知道Spring的HttpServletBean继承于HttpServlet，熟悉Servlet编程的同学都知道我们要编写一个新的Servlet只需继承HttpServlet，并重写相应的方法即可，当一个新的请求到来时，首先从Servlet接口的service方法开始，在HttpServlet的service方法中根据请求的类型不同将请求路由到对应的方法，Spring MVC的HttpServlet继承于Httpservlet类，换句话说Spring MVC也是重写了HttpServlet相应的方法来处理请求，还是内有乾坤，下面我们将遵循由整体到局部的学习方式，先了解Spring MVC处理请求的整体过程。</p>
        
          <p class="article-more-link">
            <a href="/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/" data-id="cit3wbfmn0005nworx1thuxqt" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/23/Spring MVC处理请求过程（Spring MVC源码阅读系列之二）/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="Spring MVC处理请求过程(Spring MVC源码阅读系列之二)">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-Spring MVC的创建过程（SpringMVC源码阅读系列之一）" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/18/Spring MVC的创建过程（SpringMVC源码阅读系列之一）/" class="article-date">
  <time datetime="2016-08-17T16:00:00.000Z" itemprop="datePublished">2016-08-18</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java框架/">Java框架</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/18/Spring MVC的创建过程（SpringMVC源码阅读系列之一）/">Spring MVC的创建过程(SpringMVC源码阅读系列之一)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>通常我们在学习一个框架时，会先去了解这个框架的整体结构，它的基本工作方式是如何的，然后再去了解是如何使用的，最后也是不少初级程序员止步的地方，深入源码了解其实现以及实现的意图。在这篇文章中，我们主要介绍在服务器启动项目过程中，Spring MVC框架的创建过程。首先我们先来了解一下Spring MVC的整体结构</p>
        
          <p class="article-more-link">
            <a href="/2016/08/18/Spring MVC的创建过程（SpringMVC源码阅读系列之一）/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/18/Spring MVC的创建过程（SpringMVC源码阅读系列之一）/" data-id="cit3wbfml0004nworqyl5udfk" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/18/Spring MVC的创建过程（SpringMVC源码阅读系列之一）/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="Spring MVC的创建过程(SpringMVC源码阅读系列之一)">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-Java实现简单的FTP服务器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/17/Java实现简单的FTP服务器/" class="article-date">
  <time datetime="2016-08-16T16:00:00.000Z" itemprop="datePublished">2016-08-17</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/Java实现简单的FTP服务器/">Java实现简单的FTP服务器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>学习了Java网络编程了，为了检验自己的学习程序和熟悉相关的知识点，为此，使用Java Socket编程实现了一个简单的FTP服务器。以下记录了自己整个开发的流程。</p>
        
          <p class="article-more-link">
            <a href="/2016/08/17/Java实现简单的FTP服务器/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/17/Java实现简单的FTP服务器/" data-id="cit3wbfm80001nwor044tqowi" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/17/Java实现简单的FTP服务器/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="Java实现简单的FTP服务器">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
    <article id="post-SpringMVC源码阅读系列" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <h3 href="/2016/08/17/SpringMVC源码阅读系列/" class="article-date">
  <time datetime="2016-08-16T16:00:00.000Z" itemprop="datePublished">2016-08-17</time>
</h3>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java框架/">Java框架</a>
  </div>

  </div>
  <div class="article-inner">
  <div class="curve-down">
  <div class="fill-content">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/SpringMVC源码阅读系列/">SpringMVC源码阅读系列</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
        <p>SpringMVC框架之前有零散地阅读过源码，但缺乏系统性的整理，为此将自己阅读SpringMVC的过程重新整理记录为SpringMVC源码阅读系列。</p>
<blockquote>
<p>注：如没有特别说明的地方，Spring的版本是4.1.5</p>
</blockquote>
<p>本系列主涉及的内容有：<br><a href="/2016/08/18/Spring%20MVC的创建过程（SpringMVC源码阅读系列之一）/">Spring MVC的创建过程（SpringMVC源码阅读系列之一）</a></p>
<p><a href="/2016/08/23/Spring%20MVC处理请求过程（Spring%20MVC源码阅读系列之二）/">Spring MVC处理请求过程(SpringMVC源码阅读系列之二)</a></p>

      
    </div>
    <footer class="article-footer">
      <div class="article-footer-content">
        
        <a data-url="localhost:4000/2016/08/17/SpringMVC源码阅读系列/" data-id="cit3wbfmh0003nwor6cwtjwa3" class="article-share-link">分享到</a>
        
          <a href="localhost:4000/2016/08/17/SpringMVC源码阅读系列/#ds-thread" class="article-comment-link">评论</a>
        
        
          <span id=""class="leancloud_visitors"  data-flag-title="SpringMVC源码阅读系列">
            &nbsp;&nbsp; 
            </span>
        
      </div>
    </footer>
  </div>
  </div>
  </div>
  
</article>



  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</section>
      
      <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/07/设计模式系列之学习设计模式之由/">设计模式系列之设计模式学习</a>
          </li>
        
          <li>
            <a href="/2016/09/07/设计模式系列之单例模式/">设计模式系列之单例模式</a>
          </li>
        
          <li>
            <a href="/2016/09/05/Tomcat处理请求过程（Tomcat源码阅读系列之四）/">Tomcat处理请求过程(Tomcat源码阅读系系列之四)</a>
          </li>
        
          <li>
            <a href="/2016/09/05/Tomcat的Session管理（Tomcat源码阅读系列之五）/">Tomcat的Session管理</a>
          </li>
        
          <li>
            <a href="/2016/08/27/eclipse&Myeclipse&Intellij Idea源码阅读快捷键/">eclipse&amp;Myeclipse&amp;Intellij Idea源码阅读快捷键</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java框架/">Java框架</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/开发工具/">开发工具</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/计算机网络/">计算机网络</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 WoodyOilove<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/sun11/hexo-theme-paperbox" target="_blank">Paperbox</a>
    </div>
    
<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1260393587'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s4.cnzz.com/z_stat.php%3Fid%3D1260393587%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script>

  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
  <a href="#search" class="mobile-nav-link st-search-show-outputs">Search</a>
</nav>
  

<!-- totop start -->
<div id="totop">
	<a title="返回顶部"></a>
</div>
<!-- totop end -->

<!-- swiftype search start -->

<!-- swiftype search end -->


<!-- duoshuo start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"woodyoilove"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- duoshuo end -->


<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>

<script src="//cdnjs.cloudflare.com/ajax/libs/lrsjng.jquery-qrcode/0.12.0/jquery.qrcode.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
